spring:
  jpa:
    properties:
#      javax:
#        persistence.validation.mode: none
      hibernate:
        #generate_statistics: true
        #use_sql_comments: true
        dialect: io.undertree.yb.hibernate.YugabyteDialect
        order_inserts: true
        order_updates: true
        jdbc:
          batch_size: 30  # https://github.com/hibernate/hibernate-reactive/issues/877 <- Fixed
          use_scrollable_resultset: true
          use_get_generated_keys: true
        temp.use_jdbc_metadata_defaults: false
        connection.handling_mode: DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION
        # ^ exploring why Spring is defaulting this to AND_HOLD which is known to tie up connections
    hibernate:
      ddl-auto: none
  datasource:
    hikari:
      maximum-pool-size: 10
      max-lifetime: 16000000
      #schema: default
      username: yugabyte
      data-source-class-name: com.yugabyte.ysql.YBClusterAwareDataSource
      transaction-isolation: TRANSACTION_READ_COMMITTED
      #connection-init-sql: 'select * from pg_sleep(1.7),yb_notify_log,yb_notify_log_uuid,yb_device where yb_device.deprecated != 0::boolean;'

      # The maximum number of milliseconds that a client (that's you) will wait for a connection from the pool.
      # If this time is exceeded without a connection becoming available, a SQLException will be thrown.
      #connection-timeout: 2000  # (default 30000 [30s]); also maps to YB driver's "loginTimeout"

      # controls whether the pool will "fail fast" if the pool cannot be seeded with an initial connection successfully.
      # Any positive number is taken to be the number of milliseconds to attempt to acquire an initial connection;
      # the application thread will be blocked during this period.
      # If a connection cannot be acquired before this timeout occurs, an exception will be thrown.
      # This timeout is applied after the connectionTimeout period
      initialization-fail-timeout: 30000 # (default: 1 [1ms]) adds ms to connectionTimeout during initialization;
        # ^ doesn't fail but skips filling up the rest of the pool until after the app is started... probably not desirable...

      # controls the maximum amount of time that a connection will be tested for aliveness.
      # This value must be less than the connectionTimeout. Lowest acceptable validation timeout is 250 ms. Default: 5000
      validation-timeout: 10000 # (default 5000 [5s]); fails if connectionInitSql takes longer
        # ^ make 2x (basically socketTimeout but for init phase)

      data-source-properties:
        serverName: 127.0.0.1
        portNumber: 5433
        #databaseName: default
        additionalEndpoints: 127.0.0.2,127.0.0.3
        topologyKeys: "cloud1.datacenter1.rack1"
        # socketTimeout: The timeout value used for socket read operations. If reading from the server takes longer than this value, the connection is closed. This can be used as both a brute force global query timeout and a method of detecting network problems. The timeout is specified in seconds and a value of zero means that it is disabled
        socketTimeout: 4
        # connectTimeout: The timeout value used for socket connect operations. If connecting to the server takes longer than this value, the connection is broken. The timeout is specified in seconds and a value of zero means that it is disabled.
        #connectTimeout: 5
        # loginTimeout: Specify how long to wait for establishment of a database connection. The timeout is specified in seconds.
        # NOTE: loginTimeout should be > that connectTimeout
        #loginTimeout: 15
        #cancelSignalTimeout: 0
        prepareThreshold: 1
        options: "-c statement_timeout=15s"  # needs to be longer than the init query time...